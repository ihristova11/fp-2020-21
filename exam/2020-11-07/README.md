
# Общо за всички варианти

*Важно: Решете задачите на R5RS Scheme. В решенията не може да се използват списъци, нито деструктивни операции.*

Както и в задачите от домашното, множество S от естествени числа ще представяме чрез едно естествено число, което ще наричаме негово представяне. Числото N се съдържа в S тогава и само тогава, когато N+1-вият разряд в двоичния запис на представянето е 1. Например

| Множество | Представяне | Коментар                          |
|-----------|-------------|-----------------------------------|
| {5, 1, 0} | 35          | двоичният запис на 35 е 100011(2) |
| {4, 3, 1} | 26          | двоичният запис на 26 е 11010(2)  |
| ∅         | 0           | двоичният запис на 0 е 0(2)       |

Навсякъде в задачите, където се изисква да се работи с множества, това трябва да става в така описаното представяне.

# Вариант A

Реализирайте следните функции:

А) `(revlex-less? a b)`, която сравнява две числа и проверява дали `a` е преди `b`.

Наредбата, с която се сравняват числата, да бъде лексикографската, но приложена отдясно-наляво по записа на числата.

_Примери:_

* `(revlex-less 0 5)` → `#t`
* `(revlex-less 91 5)` → `#t`
* `(revlex-less 23 123)` → `#t`
* `(revlex-less 13 23)` → `#t`
* `(revlex-less 23 23)` → `#f; (понеже са еднакви, не може 23 да е преди 23)`

***

Б) `(nset-accumulate op term init s)`, която работи сходно на функцията `(accumulate)`, но вместо да обхожда интервал [a, b), тя комбинира (в нарастващ ред) елементите на множеството `s`. Операцията `op` да се приложи ляво асоциативно.

Казано по друг начин, ако трябва да приложим операцията изваждане върху множество съдържащо елементите  
e<sub>0</sub> < e<sub>1</sub> < … < e<sub>n</sub>  
функцията трябва да пресметне:  
(… (((init - e<sub>0</sub>) - e<sub>1</sub>) - e<sub>2</sub>) … - e<sub>n</sub>)

_Пример: Нека S е множеството {1,2,5}. Тогава:_

`(nset-accumulate - id 0 S)` трябва да пресмята `(((0 - 1) - 2) - 5)`

***

В) `(nset-revlex-min s)`, която намира най-малкия (според наредбата дефинирана в точка A.) елемент на множеството `s`. Ако множеството е празно, функцията да връща `#f`.

В решението на тази подточка не може да се използва рекурсия. Вместо това направете подходящо обръщение към функцията `nset-accumulate` от точка Б.)

# Вариант Б

Реализирайте следните функции:

А) `(nset-add s elem)` и `(nset-remove s elem)`, които съответно добавят и премахват елемент към множество. Напомняме, че това са операции с множества. Например ако опитаме да добавим елемент 5 към {1,5}, резултатът ще е пак {1,5}.

***

Б) `(nset-contains-its-size s)`, която проверява дали множеството `s` съдържа в себе си броя на елементите си.

Примери:

* Множеството {1,4,7,9} е такова, защото има четири елемента и съдържа числото 4.
* Множеството {1,2,5} не е такова, защото има три елемента, но не съдържа числото 3.

***

В) `(nset-map s f)`, която получава множество `s` и операция f:ℕ→ℕ.

`nset-map` трябва да върне ново множество, което се получава от прилагането на f върху всеки от елементите на s.

Упътване: Забележете, че е възможно `f` да върне дадена стойност повече от веднъж. За да се справите с този проблем, използвайте наготово функциите от А.)

Пример: нека S е множеството {1,3,5}. Тогава:

* `(nset-map S (lambda (x) (+ x 1)))` трябва да върне {2,4,6}.
* `(nset-map S (lambda (x) 5))` трябва да върне {5}.

# Вариант В

Едно естествено число ще наричаме "валидно", ако в неговия запис никъде не се срещат две последователни нули. Например 0, 5, 123, 1230 и 1023012301 са валидни числа. 12003 и 120000000051 не са валидни числа.

Реализирайте следните функции:

А) `(number-valid? n)`, която проверява дали естественото число `n` е валидно.

***

Б) `(valid->nset n)`, която получава естестено число `n`. Ако то е валидно, функцията извлича от записа му всички числа, които се намират между нулите в записа му и от тях формира множество S, което се връща като резултат. Ако `n` не е валидно число, функцията да връща `#f`.

_Примери:_

* `(valid->nset 5050123050)` → множеството {5,123}
* `(valid->nset 0)` → празното множество
* `(valid->nset 120034)` → #f

***

В) `(make-nset a b pred?)`, която връща множеството на онези числа от естествения интервал [a,b], за които предикатът `pred?` връща истина.

В решението на тази подточка не можете да използвате рекурсия. Реализирайте `make-nset` с подходящо обръщение към функцията `accumulate`, която е дадена по-долу.

Забележка: `accumulate` трябва да се използва така както е дадена по-долу. Кодът ѝ не бива да се променя.

```scheme
(define (accumulate op term init a next b)  
  (define (loop i)
      (if (<= i b)
          (op (term i) (loop (next i)) )
          init
  ))
  (loop a)
)
```

# Вариант Г

Реализирайте следните функции:

А) `(ascending? n)`, която проверява дали цифрите в записа на числото `n` са наредени в строго нарастващ ред от старшия към младшия разряд. 

Пример: 0, 1, 123 и 1259 са такива числа, а 11, 321  и 1223 -- не са.

***

Б) `(nset-filter s pred?)`, която получава множество `s` и предикат `pred?`. Функцията връща ново множество от онези елементи на `s`, за които `pred?` връща `#t`.

***

В) Напишете функция `(nset-intersect s1 s2)`, която получава две множества `s1` и `s2` и връща ново множество -- тяхното сечение. 

В решението на тази подточка не може да се използва рекурсия. Вместо това реализирайте функцията като подходящо обръщение към `nset-filter`, с подходящи аргументи.




