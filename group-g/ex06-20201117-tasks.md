# Упражнение 6 - Структури от данни

[код от упражнението](ex06-20201117-solutions.rkt)

## Матрици
За удобство при работа с матрици ще използваме следните "стандартни" интерфейсни функции:
```
(define (head-rows m) (head m))
(define (head-cols m) (map head m))
(define (tail-rows m) (tail m))
(define (tail-cols m) (map tail m))
(define (null-m? m) (or (null? m) (null? (head m))))
```
### Зад.1.
Да се напише функция `(sub-matrix i1 j1 i2 j2 m)`, която намира подматрицата на `m` със зададени горен ляв и долен десен ъгъл `(i1,j1)` и `(i2,j2)`, съответно.
### Зад.2.
Напишете функция `(foldr-matrix op-rows nv-rows op-elems nv-elems m)`, която свива матрицата `m`, като прилага двуместната функция `op-elems` върху елементите във всеки ред, с начална стойност `nv-elems`. Резултатът от свиването на всеки от редовете се насъбира от двуместната функция `op-rows`, с начална стойност `nv-rows`. Пример:
```
(foldr-matrix + 0 * 1 (from-rows '((3 4 5) (6 7 8))))
; изчислява се като (+ (* 3 (* 4 (* 5 1)))
;                      (* 6 (* 7 (* 8 1)))
;                      0)
```
### Зад.3***.
Да се напише функция `(determinant m)`, която намира детерминантата на дадена квадратна матрица `m`.

## Двоични дървета

За удобство и консистентност ще използваме следните "стандартни" функции за работа с дървета:
```
(define (tree? t)
  (or (null? t)
      (and (list? t)
           (= (length t) 3))
           (tree? (cadr t))
           (tree? (caddr t))))
(define empty-tree '())
(define (make-tree root left right) (list root left right))      ; не искаме просто (define make-tree list) - защо?
(define (make-leaf root) (make-tree root empty-tree empty-tree)) ; за удобство
(define root-tree car)
(define left-tree cadr)
(define right-tree caddr)
(define empty-tree? null?)
```
Примерно дърво:
```
(define test-tree
  (make-tree 10
             (make-tree 7
                        (make-leaf 10)
                        (make-leaf 2))
             (make-tree 3
                        (make-tree 4
                                   (make-leaf 1)
                                   (make-leaf 2))
                        empty-tree)))
```
### Зад.4.
Да се напише функция `(tree-sum t)`, която намира сумата на всички елементи на дървото `t`.
### Зад.5.
Да се напише функция `(tree-level k t)`, която връща списък от всички стойности във възли на дълбочина `k` (тоест разстояние `k` от корена).
### Зад.6.
Да се напише функция `(all-levels t)`, която връща списък от всички нива на дървото `t`, започвайки от нулевото надолу.
### Зад.7.
Да се напише функция `(tree-map f t)`, която `map`-ва функцията `f` на всички стойности в дървото `t`.
### Зад.8.
Да се напише функция `(tree->list t)`, която връща списък от всички елементи на дървото, получени при обхождане ляво-корен-дясно.
### Зад.9.
Да се напише функция `(bst-insert val t)`, която вмъква стойността `val` в двоичното наредено дърво `t`.
### Зад.10.
Да се напише функция `(tree-sort lst)`, която сортира списъка `lst`, използвайки предишните две функции.
### Зад.11*.
Да се напише функция `(valid-bst? t)`, която проверява дали дървото `t` е валидно двоично наредено дърво.

_Упътване_: валидно ли е (по същия смисъл) следното дърво? Защо?
```
(make-tree 2
           (make-tree 1
                   empty-tree
                   (make-leaf 3))
           empty-tree)
```
### Зад.12.
Да се напише функция `(prune t)`, която премахва всички листа в дървото `t`.
### Зад.13.
Да се напише функция `(bloom t)`, която заменя всяко листо със стойност `x` със следното дърво:
```
   x
  / \
 x   x
 ```
 ### Зад.14*
 Да се напише функция `(avg t)`, която заменя всяка стойност във възлите на дадено дърво със средно-аритметичното на максималната и минималната стойност в поддървото с корен съотвеетния възел.
