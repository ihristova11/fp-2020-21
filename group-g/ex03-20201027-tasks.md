# Упражнение 3 - Функции от по-висок ред (accumulate)

[код от упражнението](ex03-20201027-solutions.rkt)

### Задача 0 [загрявка].
Напишете функцията `accumulate` и нейния итеративен вариант.
```
(define (accumulate op nv a b term next)
  (if (> a b)
      nv
      (op (term a)
          (accumulate op nv (next a) b term next))))
```
### Задача 1
Да се напише функция `(!! n)`, която по дадено естествено число `n` изчислява `n!!` - произведението на всички числа, по-малки или равни на `n`, със същата четност:
```
(!! 5) -> 15    ; =1*3*5
(!! 10) -> 3840 ; =2*4*6*8*10
```
### Задача 2
Да се напише функция `(nchk n k)`, която за дадени естествени числа `n` и `k` изчислява биномния коефициент 'n над k'.

; Упътване: тук `accumulate` се ползва индиректно от функцията факториел

; името идва от `n-choose-k` - по колко начина можем да изберем k неща измежду n

### Задача 3*
Да се напише функцията `nchk` с едно извикване на `accumulate`.

### Задача 4
Да се напише функция `(2^ n)`, която изчислява 2<sup>n</sup> (където `n` е естествено), използвайки:
- accumulate, директно
- nchk от предишната задача

### Задача 5
Да се напишат функциите `(all? p? a b)` и `(any? p? a b)`, които проверяват дали даден предикат `p?` е изпълнен за всяко (съотв. за някое) число в интервала `[a;b]`
- Упътване: не можем да използваме вградените `and` и `or` във функции от по-висок ред, но можем да си дефинираме свои, напр. `(lambda (x y) (and x y)`.

### Задача 5½ [още загрявка]
Напишете филтриращия вариант на функцията `accumulate`, отново и като итеративен процес:
```
(define (filter-accum p? op nv a b term next)
  (cond ((> a b) nv)
        ((p? a) (op (term a)
                    (filter-accum p? op nv (next a) b term next)))
        (else       (filter-accum p? op nv (next a) b term next))))
```
### Задача 6
Да се напише функция `(divisors-sum n)`, която намира сумата на всички делители на естественото число `n`.
```
(divisors-sum 12) -> 28 ;1+2+3+4+6+12=28
```
### Задача 7
Да се напише функция `(count p? a b)`, която проверява за колко измежду числата в целочисления интервал `[a;b]` е верен предиката `p?`.

### Задача 8
Да се напише функция `(prime? n)`, която проверява дали дадено число е просто:
```
(prime? 1) -> #f ;(!)
(prime? 2) -> #t
(prime? 101) -> #t
```
### Задача 8*
Да се напише функцията от по-висок ред `(repeat n f)`, която връща `n`-кратната композиция на дадена функция `f`:
```
(define f (repeat 5 (lambda (x) (+ x 1))))
(f 10) -> 15
((repeat 0 (lambda (x) (+ x 1))) 10) -> ?
```
### Задача 9
Да се напишат функции, които изчисляват апроксимации на някои популярни математически функции, използвайки първите `n` събираеми от развитието е ред на Тейлър:

![](img/taylor0.svg)
![](img/taylor1.svg)
