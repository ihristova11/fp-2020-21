# Седмица 6 - map, filter, fold

Разгледахме три важни функции от по-висок ред върху списъци, които ще използваме сравнително често. Важни са, защото покриват доста от операциите, които бихме искали да извършим върху списъци, без да ни се налага експлицитно да програмираме рекурсия. Също така, като абстракции, имат смислени и значещи имена - по-лесно е да прочетем едно извикване на `filter` вместо цяла функция, която прави същото като `filter`, но с явна рекурсия.

Започнахме с решаване на една от задачите за вкъщи, а именно - [chunk](https://github.com/semerdzhiev/fp-2020-21/blob/master/group-b/exercises/05.more-lists/06-chunk.rkt)

```racket
(define (chunk n xs)
  (define (safe-take n xs)
    (cond ((> n (length xs)) xs)
          (else (take xs n)))
  )

  (define (safe-drop n xs)
    (cond ((> n (length xs)) '())
          (else (drop xs n))))
  
  (if (null? xs)
      '()
      (cons (safe-take n xs) (chunk n (safe-drop n xs))))
)
```

Имахме нужда от `safe-take` и `safe-drop`, тъй като вградените такива функции ни дават грешка, когато ги извикаме с число, по-голямо от дължината на списъка ни. В `safe-*` функциите, вместо да хвърляме грешка, връщаме каквото сме обработили до момента.

# map

`map` приема функция и списък и ни връща списък, чийто елементи са тези от оригиналния, но с приложена дадената функция. Казано просто:

```racket
(map f '(x1 x2 x3)) ; ни дава ((f x1) (f x2) (f x3))
```

```racket
(define (map f xs)
  (if (null? xs)
      '()
      (cons (f (car xs)) (map f (cdr xs)))))
```

```racket
(map (lambda (x) (remainder x 2)) '(2 3 4))
; '(0 1 0)
(map (lambda (x) (list x x)) '(2 3 4))
; '((2 2) (3 3) (4 4))
```

## Свойства на map

* Ако дадем на `map` списък с дължина `x`, ще получим обратно списък със същата дължина
* Нямаме гаранция, че елементите на резултата ще са от същия тип и структура, както тези в дадения списък. Тоест можем, например, да преобразуваме число в низ, в списък, или в каквото решим.


# filter

`filter` приема едноместен предикат (функция, която приема един аргумент и ни връща `#t` или `#f`) и списък. Връща елементите от списъка, за които дадения предикат е изпълнен (връща `#t`)

```racket
(define (filter p? ys)
  (cond ((null? ys) '())
        ((p? (car ys)) (cons (car ys) (filter p? (cdr ys))))
        (else (filter p? (cdr ys))))
)
```

```racket
(filter (lambda (x) (> (length x) 2)) '((1 2) (1 2 3) (3 3 4 4 5) (2)))
; '((1 2 3) (3 3 4 4 5))

(filter odd? '(1 2 2 2 3 5 6 6 7))
; '(1 3 5 7)
```

## Свойства на filter

* Нямаме гаранция, че броят елементи на резултата ще е същия като на оригиналния списък (възможно е, ако предиката върне `#t` за всеки елемент)
* Знаем, че формата на елементите в резултатния списък ще е като този на оригиналния - ако филтрираме списък от низове, ще получим обратно списък от (същите) низове

# fold(l/r)

Започнахме с мотивация, сходна на `accumulate` - искаме да комбинираме елементи, но не в интервал, а от списък.

```racket
(define (sum-list xs)
  (if (null? xs)
      0
      (+ (car xs) (sum-list (cdr xs))))
)

(define (mult-list xs)
  (if (null? xs)
      1
      (* (car xs) (mult-list (cdr xs))))
)
; това ни доведе до:
(define (fold-right op nv xs)
  (if (null? xs)
      nv
      (op (car xs) (fold-right op nv (cdr xs)))))

; така горните функции стават просто
(define (sum-list xs)
  (fold-right + 0 xs)
)

(define (mult-list xs)
  (fold-right * 0 xs)
)

; Същото както при accumulate

; Функция, която ни дава най-голямото число в списък
; Приемаме, че списъкът ни има поне един елемент
(define (biggest-in-list xs)
  (if (null? xs)
      (error "called with an empty list")
      (fold-right (lambda (current res) (if (> current res) current res)) (car xs) xs))
      ;по-прост вариант - (fold max (car xs) xs))
)

```

**Ключово е да отбележим** интуицията зад функцията `op` във `fold`.  
Виждаме, че при извикване на `fold`, даваме следните имена на аргументите на `lambda` израза - `current` и `res` (от `result`). Това не е случайно. Нека видим какво се случва в самата функция `fold`:
```racket
  (op (car xs) (fold-right op nv (cdr xs)))))
```

Първият аргумент на `op` е текущия елемент от списъка. Втория е резултата от рекурсивното извикване на функцията - т.е. когато се стигне до същинското прилагане на `op` и върху двата аргумента, може да смятаме, че втория е вече натрупания резултат.

# Идеята на `op` функцията е следната:
**Приема текущия елемент на списъка и текущия резлутат и ни дава нов резултат**

т.е. казва ни как да комбинираме текущият ни елемент с натрупания вече резултат.


### filter и map написани чрез fold

```racket
(define (filter p? xs)
  (fold-right (lambda (current res)
          (if (p? current)
              (cons current res) ; <- new result
              res ; <- new result - in this case same as old
           ))
        '()
        xs
  )
)

(define (map f xs)
  (fold-right (lambda (current res) (cons (f current) res)) '() xs))
```

Тези имплементации ни казват, че `fold` е по-обща от `map` и `filter` - чрез нея може да изразим и двете функции. Обратното не е вярно.

## fold-left

Видяхме какво всъщност прави `fold-right` - комбинира елементите на списък, но го прави отзад-напред - т.е. започва от дясно. Затова се казва и `fold-right`.

Написахме и `fold-left`:

```racket
(define (fold-left op res xs)
  (if (null? xs)
      res
      (fold-left op (op res (car xs)) (cdr xs))))
```

Тъй като `fold-left` прави опашкова рекурсия, е лесно да видим, че елементите се комбинират, започвайки от ляво (от първия).

(Оскъдни) примери какво може да напишем, чрез `fold`s:

```racket
(define (reverse xs)
  (fold-right (lambda (current result) (append result (list current))) '() xs)
)

(define (clone xs)
  (fold-right cons '() xs)
)
```

Хубаво упражнение е да си разпишете защо горните извиквания работят.



