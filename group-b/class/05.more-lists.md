# Седмица 5 - Още списъци

Минахме през имплементацията на на пръв поглед случайни функции, но обърнахме внимание на следните неща покрай тях:

* Как да построим нов списък, докато обикаляме съществуващ
* Прилики и разлики между `cons` и `append` - кога използваме едното и кога - другото
* Писане на смислени общи тестове, които разчитат на свойства, които функцията ни се очаква да изпълнява
* Функциите от по-висок ред върху списъци правят рекурсията вместо нас, така че да не се стреляме в краката

Написахме `take` от последните задачки за упражнение:

```racket
(define (take n xs)
  (cond ((or (= n 0) (null? xs)) '())
        (else (cons (car xs) (take (- n 1) (cdr xs)))))
)
```

Първата функция от по-висок ред върху списъци, която разгледахме е `takeWhile`. Тя приема предикат и списък и взима първите му елементи, които отговарят на предиката. Използваме я, когато не знаем точно колко елемента от началото искаме да вземем (напр. първите 6), а имаме условие, което трябва да е изпълнено (първите четни елементи).

```racket
(define (takeWhile p? xs)
  (cond ((or (null? xs) (not (p? (car xs)))) '())
        (else (cons (car xs) (takeWhile p? (cdr xs))))))

;(takeWhile even? '(2 4 6 8 9 10 11 12)) -> '(2 4 6 8)
```

След това се отклонихме към `append`, чиято идея е да конкатенира два списъка:
`(append '(1 2 3) '(4 5 6)) -> '(1 2 3 4 5 6)`

Видяхме едно възможно решение:

```racket
(define (append xs ys)
  (cond ((and (null? xs) (null? ys)) '())
        ((not (null? xs)) (cons (car xs) (append (cdr xs) ys)))
        (else (cons (car ys) (append xs (cdr ys))))))
```

Тук казваме следното:
* Когато ни се дадат два празни списъка, очевидно тяхната конкатенация е празен списък
* Докато в `xs` има нещо, натрупваме елементите от `xs` в нов списък
* След това правим същото за `ys`
* В някакъв момент и двата ще се изчерпат и ще приключим с празен списък

Получава се това:
`(cons 1 (cons 2 (cons 3 (cons 4 (cons 5 (cons 6 '()))))))`

Моето предложение беше следното:
```racket
(define (append xs ys)
  (if (null? xs)
      ys
      (cons (car xs) (append (cdr xs) ys))))
```

Тук казваме:
* Когато първият списък е празен, не ни интересува и може да върнем директно втория
* Иначе трупаме елементите от `xs` в нов списък

Получава се:
`(cons 1 (cons 2 (cons 3 '(4 5 6)))`

**Прилики и разлики между cons и append**
```racket
(cons 1 '()) ; ни дава списъкът '(1)
(append '(1) '()) ; ни дава същото

(cons '() 1) ; ни дава обикновена двойка (не списък)
(append '() '(1)) ; ни дава списъкът от по-горе

; append очаква два списъка като аргументи
; (append 1 '()) НЕ Е окей

; cons очаква на първо място елемент на списък, а на второ - задължително списък (за да направи списък)
; (cons 1 2), (cons '() 12) не са списъци
```

Защо ни интересуваше това?

Написахме итеративна верисия на `take`

```racket
(define (take-iter n xs)
  (define (helper n xs result)
    (cond ((or (= n 0) (null? xs)) result)
          (else (helper (- n 1) (cdr xs) (cons (car xs) result)))))
  (helper n xs '()))

(take 3 '(1 2 3 4)) ; обаче ни връща '(3 2 1)
; което май не е идеално
; защо го прави?

; натрупването в result в helper става в такъв ред:
; (cons 1 '()) -> '(1)
; (cons 2 '(1)) -> '(2 1)
; (cons 3 '(2 1)) -> '(3 2 1)

; Как се справяме с това?
; явно ще сменим местата на result и (car xs)
; ама се съгласихме, че няма да стане с cons, тъй като
; (cons result (car xs)) не би ни дало списък

; На помощ идва append
; (append result (list (car xs)))
; важно е да съобразим, че append приема два списъка и трябва да превърнем (car xs) в списък, чрез list


; та крайният ни резултат бе:

(define (take-iter n xs)
  (define (helper n xs result)
    (cond ((or (= n 0) (null? xs)) result)
          (else (helper (- n 1) (cdr xs) (append result (car xs))))))
  (helper n xs '()))
```

**Selection sort**

Написахме следните две функции:

```racket
; remove-first - връща ни xs, но без първото срещане на x
(define (remove-first x xs)
  (cond ((null? xs) '())
        ((= x (car xs)) (cdr xs))
        (else (cons (car xs) (remove-first x (cdr xs))))))


; find-min - връща ни най-малкото число от непразен списък
(define (find-min xs)
  (cond ((null? (cdr xs)) (car xs))
        (else (min (car xs) (find-min (cdr xs))))))

```

Използвахме ги, за да реализираме сортиране, чрез метода на пряката селекция (линк)

```racket
(define (selection-sort xs)
  (if (null? xs)
      '()
      (else
        (let ((min-element (find-min xs)))
             (cons min-element (selection-sort (remove-first min-element xs)))))))
``` 

Видяхме смислена употреба на `let`!


Говорихме си за това как може да тестваме такава функция. В задачите за домашно обикновено виждаме тестове от типа на:

```racket
(check-equal? (selection-sort '(3 4 2 1)) '(1 2 3 4))
```

Пишейки такива тестове, трябва да внимаваме да покрием всички случаи, което обикновено е трудно и има какво да се обърка.

Вместо това, може да си измислим някакви свойства, чрез които може да тестваме функцията си със случаен вход.  
За тази функция стигнахме до следните свойства:
Оригиналният списък и този след прилагане на `selection-sort`:
* трябва да имат една дължина
* трябва да имат едни и същи елементи

* списъкът след прилагане на `selection-sort` трябва да е в нарастващ ред

или

* списъкът след прилагане на `selection-sort` трябва да е пермутация на оригиналния
* списъкът след прилагане на `selection-sort` трябва да е в нарастващ ред

За вкъщи имаме да напишем тестове, които използват тези свойства.

**Като за последно** изпрограмирахме `map`

```racket
; map - приема едноместна функция и списък. Прави следното:
; (map (lambda (x) (string-length x)) '("abc" "c" "defgh")) -> '(3 1 5)
; казано просто - дава ни нов списък, чийто елементи са оригиналните, но с извикана с тях функцията, която ни е дадена като аргумент

(define (map f xs)
  (if (null? xs)
      '()
      (cons (f (car xs)) (map f (cdr xs)))))
```

`map` е една от най-често използваните функции от по-висок ред, които ще срещнем.



