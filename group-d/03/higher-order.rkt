#lang racket

; Throwback:
; Последния път говорехме за рекурсия (опашкова) и видове рекурсивни
; процеси.
; Нещо важно: функциите в които всички рекурсивни извиквания са
; опашкови, генерират итеративен рекурсивен процес.


; Функциите, както всички останали стойности, можем
; да ги подаваме като аргументи на функции.
; Такава функция, която приема като аргумент друга функция,
; наричаме функция от по-висок ред.

(define (binary-op f x y) (f x y))
; Очаква се f да бъде функция и в тялото на binary-op я използваме като такава.
; Тоест прилагаме я върху x и y.

(binary-op + 2 3) ;5
(binary-op * 2 3) ;6

; Можем и като резултат на една функция да върнем друга.
(define (ifp p g f)
  (if p g f))

(ifp (< 1 2) + *) ;#procedure:+>
; Можем да приложим върнатата функция върху някакви аргументи
((ifp (< 1 2) + *) 5 8)  ;13
((ifp (> 1 2) + *) 5 8)  ;40

; Анонимна (ламбда) функции
; (lambda (<arg1> <arg2> .. <argn>) <body>)

; По същия начин както с именованите функции, ламбда функциите
; можем да ги подаваме като аргументи на други функции или да
; ги връщаме като резултат.

(binary-op (lambda
             (a b)
             (/ (+ a b) 2))
           10
           2) ;6
; Можем да конструираме операцията на място, вместо да правим отделна дефиниция.

; Можем и да я извикаме веднага след като я дефинираме ако искаме.
((lambda (x y) (gcd x y)) 17 6) ;1
; ОЩЕ СКОБИ!


; Важно е че анонимната функция пази указател към средата,
; в която е оценена.
; TODO примери


;;;;;;;;;;
; ЗАДАЧИ ;
;;;;;;;;;;

; Идентитета не е част от R5RS, може да ви потрябва :)
(define (id x) x)

; * Вече писахме функция, която намира сумата на числа в интервал.
; acc (акумулатор) - начална стойност и променлива в която
; натрупваме, полученият досега резултат.

; 1. Намира сумата на израз от числата в даден интервал
; - term(x), за всяко x от интервала при сумиране
; Пример: сума на x^2, x/4, 2^x и т.н.
(define (sum-term from to term acc) void)

; 2. Напишете функция като горната,
; но натрупва резултата с произволна бинарна операция op.
; Реализирайте я чрез итеративен процес.
; Пример: сума, произведение, дизюнкция и т.н.
(define (accumulate from to op term acc) void)

; 3. Реализирайте факториел чрез accumulate.
(define (fact n) void)

; 4. Намира броя на числата в интервал, които изпълняват даден предикат.
; Реализирайте я чрез accumulate.
(define (count-p from to p) void)

; 5. Проверява дали даден предикат е верен за всички числа в даден интервал.
; Реализирайте я чрез accumulate.
(define (for-all? from to p) void)

; 6 .Тя проверява дали някое число в даден интервал изпълнява даден предикат.
; Реализирайте я чрез accumulate.
(define (exists? from to p) void)

; 7. За даден едноместен предикат p, връща отрицанието му.
; Не отрицанието на резултата, а нов предикат който е отрицание на p.
(define (complement p) void)

; 8. За дадена функция на два аргумента f,
; връща функцията над разменени аргументи.
(define (flip f) void)

; 9. Взима едноаргументна функция f и връща композицията (f∘f)
(define (double f) void)

; 10. За дадени едноаргументни функции f и g връща композицията им (f∘f)
(define (compose f g) void)

; 11. За дадена едноаргументна функция f и число n,
; връща n-тото прилагане на f. Тоест f^n.
; Пример: (repeat f 3) x) ще е същото като (f (f (f x)))
(define (repeat f n) void)
