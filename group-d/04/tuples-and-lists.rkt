#lang racket

; НАРЕДЕНИ ДВОЙКИ
; cons създава наредена 2-ка
(cons 1 #\a) ; '(1 . #\a)
; Тук точката индикира че това е наредена 2-ка, а не списък
(list 1 2 3 4) ; в списъка няма точка

(define pair '("head" . "tail"))

; Имаме предикати, които проверяват дали дадена стойност е от конкретен тип.
; Има такъв и за наредените двойки.
(pair? pair) ; #t

; Функции с които достъпваме елементите на наредена двойка.

; Първия елемент (Contents of the Address Register)
(car pair)   ; "hello"

; Втория елемент (Contents of the Data Register)
(cdr pair)   ; "world"


(define deep-list
  '((1 2) ((3 4) 5)))
; има съкратен синтаксис за комбиниране на car и cdr
; caar - първия елемент на първия елемент
; cdar - втория елемент на първия елемент
; и т.н.
; Може да ги четете отзад напред за по-лесно
(caar deep-list)  ; 1
(cdar deep-list)  ; (2)


; СРАВНЕНИЯ
; (= a b) работи само за числа

; (eq? a b) проверява дали a и b са един и същ обект
; (на едно и също място в паметта)

; (eqv? a b) същото като eq? с изключение за някои типове, като char и integer.
; Т.е. за тези типове eqv? дава различен резултат от eq?.

; (equal? a b) същото като eqv? с изключение за много типове.
; Работи за списъци и и може да сравнява покомпонентно.


; СПИСЪЦИ И QUOTE
; 1. '() е списък
; 2. (head . tail) е списък <=> tail е списък

(list 1 2 3 4) ; построява списък от подадените аргументи
; може и с quote
'(1 2 3 4)
; може и с quote - буквално
(quote (1 2 3 4))

; Каква е разликата обаче дали ползваме list или quote,
; за да конструираме списък.

; quote е специална форма и не оценява аргументите си,
; а се прилага "рекурсивно" върху тях
'(1 2 3)
; е същото като
(list '1 '2 '3)

; съответно може да видите разлика, ако в примера има какво да се оцени
'(+ 1 2)      ; тук + е само символ (символ /= char, по скоро immutable string)
(list + 1 2)  ; тук + е процедура
; или ако на мястото на някой елемент сложим променлива
; quote ще вземе буквално името й като символ, а list ще я оцени

'(1 . (2 . (3 . (4 . 5))))  ; '(1 2 3 4 . 5) - наредена 2ка
'(1 . (2 . (3 . (4 . ())))) ; '(1 2 3 4) - списък (и наредена 2-ка)

(pair? '()) ; #f
(list? '()) ; #t
(null? '()) ; #t
; null? e доста удобно

; ВГРАДЕНИ ФУНКЦИИ ЗА СПИСЪЦИ:
; (length <list>)- дължина
; (append <list1> ... <listn>) - конкатенация
; (reverse <list>)- връща списък от елементите в обратен ред
; (list-tail <list> n)- връща елементите без последните n
; (list-ref <list> n) - връща n-тия елемент
; (member <element> <list>)- връща опашката на списъка от търсения елемент нататък,
;   #f - ако няма такъв елемент (използва equal?)
; (memv <element> <list>) - като member, но използва eqv?
; (memq <element> <list>) като member, но използва eq?

; ФУНКЦИИ ОТ ПО–ВИСОК РЕД ВЪРХУ СПИСЪЦИ:
; (map <func> <list>) - връща нов списък, където върху всеки елемент е приложена подадената функция
; (filter <pred> <list>) - връща списъка само с елементите, които изпълняват дадения предикат
; (foldr <func> <init> <list>) - акумулира стойност чрез func, започвайки от init и продължавайки
;   прилагането по елементите на list (списъка се обхожда от дясно наляво)
; (foldl <func> <init> <list>) - акумулира стойност чрез func, започвайки от init и продължавайки
;   прилагането по елементипо на list (списъка се обхожда от ляво надясно)
; NOTE: Спомнете си за accumulate
; NOTE: foldr генерира линеен рекурсивен процес, а foldl линеен итеративен


;;;;;;;;;;
; ЗАДАЧИ ;
;;;;;;;;;;

; NOTE: Суфикса * е защото съществуват вградени процедури със същите имена.

; 1. Намира дължината на списъка lst.
(define (length* lst) void)

; 2. Намира сумата на елементите на списъка lst. Предполага се че са само числа.
(define (sum lst) void)

; 3. Връща последния елемент на списъка lst.
(define (last* lst) void)

; 4. Връща n-тия елемент на списъка lst.
(define (nth n lst) void)

; 5. Връща конкатенацията на lst1 и lst2.
(define (concat lst1 lst2) void)

; 6. Прилага fn над елементите на lst, връща новия списък.
(define (map* fn lst) void)

; 7. Връща списък от елементите на lst, за които предиката p е верен
(define (filter* p lst) void)

; 8. Връща списък от 2 елемента - списъци
;   - Елементите от lst изпълняващи предиката p
;   - Останалите елементи на lst
(define (partition* p lst) void)

; NOTE: Вградената функция partition работи малко по-различно
;       - връща (values lst1 lst2)
